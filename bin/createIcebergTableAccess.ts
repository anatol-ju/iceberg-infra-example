#!/usr/bin/env node
import 'source-map-support/register';

import { Duration } from 'aws-cdk-lib';
import { ManagedPolicy } from 'aws-cdk-lib/aws-iam';
import { SqsEventSource } from 'aws-cdk-lib/aws-lambda-event-sources';
import { RetentionDays } from 'aws-cdk-lib/aws-logs';
import * as fs from 'fs';
import * as path from 'path';

import { DockerImageLambdaFunctionProps, TableDefinition } from '../lib/interfaces';
import { DockerImageLambdaFunctionStack } from '../lib/lambdaFunctionStack';
import { SqsStack } from '../lib/sqsStack';
import { addIcebergAccessToRolePolicy } from '../lib/utils';
import { app, stackProps } from './index';

const { account, region } = stackProps.env || {};
const environment = stackProps.environment;

const STACKPREFIX = "iceberg-table-access";

////////////////////////////////////////////////////////////////////////////////
// Tables
//
// The tables are defined in a JSON file, located in
// src/lambdas/iceberg_table_access/table_definitions.json
////////////////////////////////////////////////////////////////////////////////

const rawDefinitions: Record<string, string> = JSON.parse(
    fs.readFileSync(
        path.join(__dirname, "../src/lambdas/iceberg_table_access/table_definitions.json"),
        "utf8"
    )
);

// Replace {env} with the environment name in the table definitions
const TABLE_DEFINITIONS: Record<string, string> = JSON.parse(
    JSON.stringify(rawDefinitions).replace(/\{env\}/g, environment)
);

////////////////////////////////////////////////////////////////////////////////
// SQS
////////////////////////////////////////////////////////////////////////////////

const sqsStacks: Record<string, SqsStack> = {};

Object.keys(TABLE_DEFINITIONS).forEach((tableId) => {
    const id = `${STACKPREFIX}-${tableId.charAt(0).toUpperCase() + tableId.slice(1)}`;
    const queueStack = new SqsStack(app, `${id}-SQS`, stackProps);
    queueStack.build({
        isFifo: false,
        isDlq: false,
        visibilityTimeout: Duration.minutes(2)
    });
    sqsStacks[tableId] = queueStack;
});

////////////////////////////////////////////////////////////////////////////////
// Lambda Functions
////////////////////////////////////////////////////////////////////////////////

Object.entries(TABLE_DEFINITIONS).forEach(([tableId]) => {
    const id = `${STACKPREFIX}-${tableId.charAt(0).toUpperCase() + tableId.slice(1)}`;

    // Read digest from a file generated by build_images.sh to ensure
    // the correct version of the image is used in the Lambda function.
    const digestPath = path.join(__dirname, "..", "build", "lambda_iceberg_table_access_digest.txt");
    const tagOrDigest = fs.readFileSync(digestPath, "utf-8").trim();

    const lambdaProps: DockerImageLambdaFunctionProps = {
        functionName: `${id}-DeliveryLambda`,
        description: "A Python Lambda function that processes SQS messages and writes to Iceberg tables.",
        reservedConcurrentExecutions: 1,
        eventSources: [
            new SqsEventSource(sqsStacks[tableId].queue, {
                maxBatchingWindow: Duration.minutes(2), // only if not FIFO
                batchSize: 1000 // maximum for non FIFO queues is 10000
            })
        ],
        environmentVariables: {
            REGION: region,
            ENV: environment,
            DATALAKEHOUSE_NAME: "datalakehouse",
            TABLE_DEFINITION: TABLE_DEFINITIONS[tableId]
        },
        pythonVersion: "3.12",
        memorySize: 250,
        logRetention: RetentionDays.ONE_WEEK,
        timeout: Duration.minutes(5),
        repositoryName: `${STACKPREFIX}-${environment}-iceberg-lambdas`,
        tagOrDigest: tagOrDigest,
        setVersion: true
    };
    const lambdaFunction = new DockerImageLambdaFunctionStack(app, `${id}-Lambda`, stackProps);
    lambdaFunction.build(lambdaProps);

    // Grant SQS and KMS permissions
    sqsStacks[tableId].queue.grantConsumeMessages(lambdaFunction.function);
    sqsStacks[tableId].queue.grantSendMessages(lambdaFunction.function);
    sqsStacks[tableId].kmsKey.grantEncryptDecrypt(lambdaFunction.function);

    // Attach AWS-managed policy for logs
    lambdaFunction.function.role?.addManagedPolicy(
        ManagedPolicy.fromAwsManagedPolicyName("service-role/AWSLambdaBasicExecutionRole")
    );

    // Attach boilerplate policy statements (Athena, Glue, S3)
    addIcebergAccessToRolePolicy(
        lambdaFunction.function,
        {
            account: account,
            region: region,
            environment: environment,
            s3Resources: []
        }
    );
})
